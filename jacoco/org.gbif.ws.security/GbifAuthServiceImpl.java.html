<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GbifAuthServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common Web service</a> &gt; <a href="index.source.html" class="el_package">org.gbif.ws.security</a> &gt; <span class="el_source">GbifAuthServiceImpl.java</span></div><h1>GbifAuthServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.ws.security;

import org.gbif.ws.server.GbifHttpServletRequestWrapper;

import java.net.URI;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;

import static org.gbif.ws.util.SecurityConstants.GBIF_SCHEME_PREFIX;
import static org.gbif.ws.util.SecurityConstants.HEADER_CONTENT_MD5;
import static org.gbif.ws.util.SecurityConstants.HEADER_GBIF_USER;
import static org.gbif.ws.util.SecurityConstants.HEADER_ORIGINAL_REQUEST_URL;

/**
 * The GBIF authentication scheme is modelled after the Amazon scheme on how to sign REST HTTP
 * requests using a private key. It uses the standard HTTP Authorization header to transport the
 * following information: Authorization: GBIF applicationKey:signature
 *
 * &lt;p&gt;&lt;br&gt;
 * The header starts with the authentication scheme (GBIF), followed by the plain applicationKey
 * (the public key) and a unique signature for the very request which is generated using a fixed set
 * of request attributes which are then encrypted by a standard HMAC-SHA1 algorithm.
 *
 * &lt;p&gt;&lt;br&gt;
 * A POST request with a GBIF header would look like this:
 *
 * &lt;pre&gt;
 * POST /dataset HTTP/1.1
 * Host: api.gbif.org
 * Date: Mon, 26 Mar 2007 19:37:58 +0000
 * x-gbif-user: trobertson
 * Content-MD5: LiFThEP4Pj2TODQXa/oFPg==
 * Authorization: GBIF gbif.portal:frJIUN8DYpKDtOLCwo//yllqDzg=
 * &lt;/pre&gt;
 *
 * &lt;p&gt;When signing an HTTP request in addition to the Authorization header some additional custom
 * headers are added which are used to sign and digest the message. &lt;br&gt; x-gbif-user is added to
 * transport a proxied user in which the application is acting. &lt;br&gt; Content-MD5 is added if a body
 * entity exists. See Content-MD5 header specs: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.15
 */
@Service
public class GbifAuthServiceImpl implements GbifAuthService {

<span class="fc" id="L67">  private static final Logger LOG = LoggerFactory.getLogger(GbifAuthServiceImpl.class);</span>

<span class="fc" id="L69">  private static final Pattern COLON_PATTERN = Pattern.compile(&quot;:&quot;);</span>

  private final SigningService signingService;
  private final Md5EncodeService md5EncodeService;
  private final AppKeyProvider appKeyProvider;

  public GbifAuthServiceImpl(
      SigningService signingService,
      Md5EncodeService md5EncodeService,
<span class="fc" id="L78">      @Autowired(required = false) AppKeyProvider appKeyProvider) {</span>
<span class="fc" id="L79">    this.signingService = signingService;</span>
<span class="fc" id="L80">    this.md5EncodeService = md5EncodeService;</span>
<span class="fc" id="L81">    this.appKeyProvider = appKeyProvider;</span>
<span class="fc" id="L82">  }</span>

  @Override
  public boolean isValidRequest(final GbifHttpServletRequestWrapper request) {
    // parse auth header
<span class="fc" id="L87">    final String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);</span>
<span class="pc bpc" id="L88" title="2 of 4 branches missed.">    if (Strings.isNullOrEmpty(authHeader) || !authHeader.startsWith(GBIF_SCHEME_PREFIX)) {</span>
<span class="nc" id="L89">      LOG.info(&quot;{} header is no GBIF scheme&quot;, HttpHeaders.AUTHORIZATION);</span>
<span class="nc" id="L90">      return false;</span>
    }

<span class="fc" id="L93">    String[] values = COLON_PATTERN.split(authHeader.substring(5), 2);</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    if (values.length &lt; 2) {</span>
<span class="nc" id="L95">      LOG.warn(&quot;Invalid syntax for application key and signature: {}&quot;, authHeader);</span>
<span class="nc" id="L96">      return false;</span>
    }

<span class="fc" id="L99">    final String appKey = values[0];</span>
<span class="fc" id="L100">    final String signatureFound = values[1];</span>
<span class="pc bpc" id="L101" title="2 of 4 branches missed.">    if (appKey == null || signatureFound == null) {</span>
<span class="nc" id="L102">      LOG.warn(&quot;Authentication header missing applicationKey or signature: {}&quot;, authHeader);</span>
<span class="nc" id="L103">      return false;</span>
    }

<span class="fc" id="L106">    final RequestDataToSign requestDataToSign = buildRequestDataToSign(request);</span>
<span class="fc" id="L107">    LOG.debug(&quot;Request data to sign: {}&quot;, requestDataToSign.stringToSign());</span>
    // sign
    final String signature;
    try {
<span class="fc" id="L111">      signature = signingService.buildSignature(requestDataToSign, appKey);</span>
<span class="nc" id="L112">    } catch (PrivateKeyNotFoundException e) {</span>
<span class="nc" id="L113">      LOG.debug(&quot;Private key was not found for app key {}&quot;, appKey);</span>
<span class="nc" id="L114">      return false;</span>
<span class="fc" id="L115">    }</span>
    // compare signatures
<span class="fc bfc" id="L117" title="All 2 branches covered.">    if (signatureFound.equals(signature)) {</span>
<span class="fc" id="L118">      LOG.debug(&quot;Trusted application with matching signatures&quot;);</span>
<span class="fc" id="L119">      return true;</span>
    }
<span class="fc" id="L121">    LOG.info(&quot;Invalid signature: {}&quot;, authHeader);</span>

<span class="fc" id="L123">    return false;</span>
  }

  private RequestDataToSign buildRequestDataToSign(final GbifHttpServletRequestWrapper request) {
<span class="fc" id="L127">    final HttpHeaders headers = request.getHttpHeaders();</span>
<span class="fc" id="L128">    final RequestDataToSign dataToSign = new RequestDataToSign();</span>

<span class="fc" id="L130">    dataToSign.setMethod(request.getMethod());</span>
    // custom header set by varnish overrides real URI
    // see http://dev.gbif.org/issues/browse/GBIFCOM-137
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">    if (headers.containsKey(HEADER_ORIGINAL_REQUEST_URL)) {</span>
<span class="fc" id="L134">      dataToSign.setUrl(headers.getFirst(HEADER_ORIGINAL_REQUEST_URL));</span>
    } else {
<span class="nc" id="L136">      dataToSign.setUrl(getCanonicalizedPath(request.getRequestURI()));</span>
    }
<span class="fc" id="L138">    dataToSign.setContentType(headers.getFirst(HttpHeaders.CONTENT_TYPE));</span>
<span class="fc" id="L139">    dataToSign.setContentTypeMd5(headers.getFirst(HEADER_CONTENT_MD5));</span>
<span class="fc" id="L140">    dataToSign.setUser(headers.getFirst(HEADER_GBIF_USER));</span>

<span class="fc" id="L142">    return dataToSign;</span>
  }

  /**
   * @return an absolute uri of the resource path alone, excluding host, scheme and query parameters
   */
  private String getCanonicalizedPath(final String strUri) {
<span class="fc" id="L149">    return URI.create(strUri).normalize().getPath();</span>
  }

  /**
   * Signs a request by adding a Content-MD5 and Authorization header. For PUT/POST requests that
   * contain a body entity the Content-MD5 header is created using the same JSON mapper for
   * serialization as the clients use.
   *
   * &lt;p&gt;Other formats than JSON are not supported currently !!!
   */
  @Override
  public GbifHttpServletRequestWrapper signRequest(
      final String username, final GbifHttpServletRequestWrapper request) {
<span class="fc" id="L162">    String appKey = appKeyProvider.get();</span>
<span class="fc" id="L163">    Preconditions.checkNotNull(appKey, &quot;To sign the request a single application key is required&quot;);</span>
    // first add custom GBIF headers so we can use them to build the string to sign
    // the proxied username
<span class="fc" id="L166">    request.getHttpHeaders().add(HEADER_GBIF_USER, username);</span>

    // the canonical path header
<span class="fc" id="L169">    request</span>
<span class="fc" id="L170">        .getHttpHeaders()</span>
<span class="fc" id="L171">        .add(HEADER_ORIGINAL_REQUEST_URL, getCanonicalizedPath(request.getRequestURI()));</span>

<span class="fc" id="L173">    String content = null;</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">    if (request.getContent() != null) {</span>
<span class="fc" id="L175">      content = request.getContent();</span>
    }

    // adds content md5
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">    if (!Strings.isNullOrEmpty(content)) {</span>
<span class="fc" id="L180">      request.getHttpHeaders().add(HEADER_CONTENT_MD5, md5EncodeService.encode(content));</span>
    }

    // build the unique request data object to sign
<span class="fc" id="L184">    final RequestDataToSign requestDataToSign = buildRequestDataToSign(request);</span>

    // sign
    final String signature;
    try {
<span class="fc" id="L189">      signature = signingService.buildSignature(requestDataToSign, appKey);</span>
<span class="nc" id="L190">    } catch (PrivateKeyNotFoundException e) {</span>
<span class="nc" id="L191">      LOG.warn(&quot;Skip signing request with unknown application key: {}&quot;, appKey);</span>
<span class="nc" id="L192">      return request;</span>
<span class="fc" id="L193">    }</span>

    // build authorization header string
<span class="fc" id="L196">    final String header = buildAuthHeader(appKey, signature);</span>
    // add authorization header
<span class="fc" id="L198">    LOG.debug(</span>
        &quot;Adding authentication header to request {} for proxied user {} : {}&quot;,
<span class="fc" id="L200">        request.getRequestURI(),</span>
        username,
        header);
<span class="fc" id="L203">    request.getHttpHeaders().add(HttpHeaders.AUTHORIZATION, header);</span>

<span class="fc" id="L205">    return request;</span>
  }

  private static String buildAuthHeader(String applicationKey, String signature) {
<span class="fc" id="L209">    return GBIF_SCHEME_PREFIX + applicationKey + ':' + signature;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>