<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BridgeMethodResolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common Web service</a> &gt; <a href="index.source.html" class="el_package">org.gbif.ws.util.spring</a> &gt; <span class="el_source">BridgeMethodResolver.java</span></div><h1>BridgeMethodResolver.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.ws.util.spring;

import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Helper for resolving synthetic {@link Method#isBridge bridge Methods} to the
 * {@link Method} being bridged.
 * &lt;p&gt;Given a synthetic {@link Method#isBridge bridge Method} returns the {@link Method}
 * being bridged. A bridge method may be created by the compiler when extending a
 * parameterized type whose methods have parameterized arguments. During runtime
 * invocation the bridge {@link Method} may be invoked and/or used via reflection.
 * When attempting to locate annotations on {@link Method Methods}, it is wise to check
 * for bridge {@link Method Methods} as appropriate and find the bridged {@link Method}.
 * &lt;p&gt;See &lt;a href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5&quot;&gt;
 * The Java Language Specification&lt;/a&gt; for more details on the use of bridge methods.
 * &lt;p&gt;Only usable on JDK 1.5 and higher. Use an appropriate {@link JdkVersion}
 * check before calling this class, if a fallback for JDK 1.4 is desirable.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @see JdkVersion
 * @since 2.0
 */
<span class="nc" id="L47">public abstract class BridgeMethodResolver {</span>

  /**
   * Find the original method for the supplied {@link Method bridge Method}.
   * &lt;p&gt;It is safe to call this method passing in a non-bridge {@link Method} instance.
   * In such a case, the supplied {@link Method} instance is returned directly to the caller.
   * Callers are &lt;strong&gt;not&lt;/strong&gt; required to check for bridging before calling this method.
   *
   * @throws IllegalStateException if no bridged {@link Method} can be found
   */
  public static Method findBridgedMethod(Method bridgeMethod) {
<span class="nc" id="L58">    Assert.notNull(bridgeMethod, &quot;Method must not be null&quot;);</span>

<span class="nc bnc" id="L60" title="All 2 branches missed.">    if (!bridgeMethod.isBridge()) {</span>
<span class="nc" id="L61">      return bridgeMethod;</span>
    }

    // Gather all methods with matching name and parameter size.
<span class="nc" id="L65">    List candidateMethods = new ArrayList();</span>
<span class="nc" id="L66">    Method[] methods = ReflectionUtils.getAllDeclaredMethods(bridgeMethod.getDeclaringClass());</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L68">      Method candidateMethod = methods[i];</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">      if (isBridgedCandidateFor(candidateMethod, bridgeMethod)) {</span>
<span class="nc" id="L70">        candidateMethods.add(candidateMethod);</span>
      }
    }

    Method result;
    // Now perform simple quick checks.
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (candidateMethods.size() == 1) {</span>
<span class="nc" id="L77">      result = (Method) candidateMethods.get(0);</span>
    } else {
<span class="nc" id="L79">      result = searchCandidates(candidateMethods, bridgeMethod);</span>
    }

<span class="nc bnc" id="L82" title="All 2 branches missed.">    if (result == null) {</span>
<span class="nc" id="L83">      throw new IllegalStateException(</span>
          &quot;Unable to locate bridged method for bridge method '&quot; + bridgeMethod + &quot;'&quot;);
    }

<span class="nc" id="L87">    return result;</span>
  }

  /**
   * Search for the bridged method in the given candidates.
   *
   * @param candidateMethods the List of candidate Methods
   * @param bridgeMethod     the bridge method
   *
   * @return the bridged method, or &lt;code&gt;null&lt;/code&gt; if none found
   */
  private static Method searchCandidates(List candidateMethods, Method bridgeMethod) {
<span class="nc" id="L99">    Map typeParameterMap = createTypeVariableMap(bridgeMethod.getDeclaringClass());</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">    for (int i = 0; i &lt; candidateMethods.size(); i++) {</span>
<span class="nc" id="L101">      Method candidateMethod = (Method) candidateMethods.get(i);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">      if (isBridgeMethodFor(bridgeMethod, candidateMethod, typeParameterMap)) {</span>
<span class="nc" id="L103">        return candidateMethod;</span>
      }
    }
<span class="nc" id="L106">    return null;</span>
  }

  /**
   * Return &lt;code&gt;true&lt;/code&gt; if the supplied '&lt;code&gt;candidateMethod&lt;/code&gt;' can be
   * consider a validate candidate for the {@link Method} that is {@link Method#isBridge() bridged}
   * by the supplied {@link Method bridge Method}. This method performs inexpensive
   * checks and can be used quickly filter for a set of possible matches.
   */
  private static boolean isBridgedCandidateFor(Method candidateMethod, Method bridgeMethod) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">    return (!candidateMethod.isBridge()</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        &amp;&amp; !candidateMethod.equals(bridgeMethod)</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        &amp;&amp; candidateMethod.getName().equals(bridgeMethod.getName())</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        &amp;&amp; candidateMethod.getParameterTypes().length == bridgeMethod.getParameterTypes().length);</span>
  }

  /**
   * Determine whether or not the bridge {@link Method} is the bridge for the
   * supplied candidate {@link Method}.
   */
  static boolean isBridgeMethodFor(
      Method bridgeMethod, Method candidateMethod, Map typeVariableMap) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (isResolvedTypeMatch(candidateMethod, bridgeMethod, typeVariableMap)) {</span>
<span class="nc" id="L129">      return true;</span>
    }
<span class="nc" id="L131">    Method method = findGenericDeclaration(bridgeMethod);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">    return (method != null ? isResolvedTypeMatch(method, candidateMethod, typeVariableMap) : false);</span>
  }

  /**
   * Search for the generic {@link Method} declaration whose erased signature
   * matches that of the supplied bridge method.
   *
   * @throws IllegalStateException if the generic declaration cannot be found
   */
  private static Method findGenericDeclaration(Method bridgeMethod) {
    // Search parent types for method that has same signature as bridge.
<span class="nc" id="L143">    Class superclass = bridgeMethod.getDeclaringClass().getSuperclass();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">    while (!Object.class.equals(superclass)) {</span>
<span class="nc" id="L145">      Method method = searchForMatch(superclass, bridgeMethod);</span>
<span class="nc bnc" id="L146" title="All 4 branches missed.">      if (method != null &amp;&amp; !method.isBridge()) {</span>
<span class="nc" id="L147">        return method;</span>
      }
<span class="nc" id="L149">      superclass = superclass.getSuperclass();</span>
<span class="nc" id="L150">    }</span>

    // Search interfaces.
<span class="nc" id="L153">    Class[] interfaces = ClassUtils.getAllInterfacesForClass(bridgeMethod.getDeclaringClass());</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">    for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L155">      Class anInterface = interfaces[i];</span>
<span class="nc" id="L156">      Method method = searchForMatch(anInterface, bridgeMethod);</span>
<span class="nc bnc" id="L157" title="All 4 branches missed.">      if (method != null &amp;&amp; !method.isBridge()) {</span>
<span class="nc" id="L158">        return method;</span>
      }
    }

<span class="nc" id="L162">    return null;</span>
  }

  /**
   * Return &lt;code&gt;true&lt;/code&gt; if the {@link Type} signature of both the supplied
   * {@link Method#getGenericParameterTypes() generic Method} and concrete {@link Method}
   * are equal after resolving all {@link TypeVariable TypeVariables} using the supplied
   * {@link #createTypeVariableMap TypeVariable Map}, otherwise returns &lt;code&gt;false&lt;/code&gt;.
   */
  private static boolean isResolvedTypeMatch(
      Method genericMethod, Method candidateMethod, Map typeVariableMap) {
<span class="nc" id="L173">    Type[] genericParameters = genericMethod.getGenericParameterTypes();</span>
<span class="nc" id="L174">    Class[] candidateParameters = candidateMethod.getParameterTypes();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (genericParameters.length != candidateParameters.length) {</span>
<span class="nc" id="L176">      return false;</span>
    }
<span class="nc bnc" id="L178" title="All 2 branches missed.">    for (int i = 0; i &lt; genericParameters.length; i++) {</span>
<span class="nc" id="L179">      Type genericParameter = genericParameters[i];</span>
<span class="nc" id="L180">      Class candidateParameter = candidateParameters[i];</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">      if (candidateParameter.isArray()) {</span>
        // An array type: compare the component type.
<span class="nc" id="L183">        Type rawType = getRawType(genericParameter, typeVariableMap);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (rawType instanceof GenericArrayType) {</span>
<span class="nc" id="L185">          if (!candidateParameter</span>
<span class="nc" id="L186">              .getComponentType()</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">              .equals(</span>
<span class="nc" id="L188">                  getRawType(</span>
<span class="nc" id="L189">                      ((GenericArrayType) rawType).getGenericComponentType(), typeVariableMap))) {</span>
<span class="nc" id="L190">            return false;</span>
          }
          break;
        }
      }
      // A non-array type: compare the type itself.
<span class="nc bnc" id="L196" title="All 2 branches missed.">      if (!candidateParameter.equals(getRawType(genericParameter, typeVariableMap))) {</span>
<span class="nc" id="L197">        return false;</span>
      }
    }
<span class="nc" id="L200">    return true;</span>
  }

  /**
   * Determine the raw type for the given generic parameter type.
   */
  private static Type getRawType(Type genericType, Map typeVariableMap) {
<span class="nc bnc" id="L207" title="All 2 branches missed.">    if (genericType instanceof TypeVariable) {</span>
<span class="nc" id="L208">      TypeVariable tv = (TypeVariable) genericType;</span>
<span class="nc" id="L209">      Type result = (Type) typeVariableMap.get(tv);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">      return (result != null ? result : Object.class);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">    } else if (genericType instanceof ParameterizedType) {</span>
<span class="nc" id="L212">      return ((ParameterizedType) genericType).getRawType();</span>
    } else {
<span class="nc" id="L214">      return genericType;</span>
    }
  }

  /**
   * If the supplied {@link Class} has a declared {@link Method} whose signature matches
   * that of the supplied {@link Method}, then this matching {@link Method} is returned,
   * otherwise &lt;code&gt;null&lt;/code&gt; is returned.
   */
  private static Method searchForMatch(Class type, Method bridgeMethod) {
<span class="nc" id="L224">    return ReflectionUtils.findMethod(</span>
<span class="nc" id="L225">        type, bridgeMethod.getName(), bridgeMethod.getParameterTypes());</span>
  }

  /**
   * Build a mapping of {@link TypeVariable#getName TypeVariable names} to concrete
   * {@link Class} for the specified {@link Class}. Searches all super types,
   * enclosing types and interfaces.
   */
  static Map createTypeVariableMap(Class cls) {
<span class="nc" id="L234">    Map typeVariableMap = new HashMap();</span>

    // interfaces
<span class="nc" id="L237">    extractTypeVariablesFromGenericInterfaces(cls.getGenericInterfaces(), typeVariableMap);</span>

    // super class
<span class="nc" id="L240">    Type genericType = cls.getGenericSuperclass();</span>
<span class="nc" id="L241">    Class type = cls.getSuperclass();</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    while (!Object.class.equals(type)) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">      if (genericType instanceof ParameterizedType) {</span>
<span class="nc" id="L244">        ParameterizedType pt = (ParameterizedType) genericType;</span>
<span class="nc" id="L245">        populateTypeMapFromParameterizedType(pt, typeVariableMap);</span>
      }
<span class="nc" id="L247">      extractTypeVariablesFromGenericInterfaces(type.getGenericInterfaces(), typeVariableMap);</span>
<span class="nc" id="L248">      genericType = type.getGenericSuperclass();</span>
<span class="nc" id="L249">      type = type.getSuperclass();</span>
    }

    // enclosing class
<span class="nc" id="L253">    type = cls;</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">    while (type.isMemberClass()) {</span>
<span class="nc" id="L255">      genericType = type.getGenericSuperclass();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (genericType instanceof ParameterizedType) {</span>
<span class="nc" id="L257">        ParameterizedType pt = (ParameterizedType) genericType;</span>
<span class="nc" id="L258">        populateTypeMapFromParameterizedType(pt, typeVariableMap);</span>
      }
<span class="nc" id="L260">      type = type.getEnclosingClass();</span>
    }

<span class="nc" id="L263">    return typeVariableMap;</span>
  }

  private static void extractTypeVariablesFromGenericInterfaces(
      Type[] genericInterfaces, Map typeVariableMap) {
<span class="nc bnc" id="L268" title="All 2 branches missed.">    for (int i = 0; i &lt; genericInterfaces.length; i++) {</span>
<span class="nc" id="L269">      Type genericInterface = genericInterfaces[i];</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">      if (genericInterface instanceof ParameterizedType) {</span>
<span class="nc" id="L271">        ParameterizedType pt = (ParameterizedType) genericInterface;</span>
<span class="nc" id="L272">        populateTypeMapFromParameterizedType(pt, typeVariableMap);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (pt.getRawType() instanceof Class) {</span>
<span class="nc" id="L274">          extractTypeVariablesFromGenericInterfaces(</span>
<span class="nc" id="L275">              ((Class) pt.getRawType()).getGenericInterfaces(), typeVariableMap);</span>
        }
<span class="nc bnc" id="L277" title="All 2 branches missed.">      } else if (genericInterface instanceof Class) {</span>
<span class="nc" id="L278">        extractTypeVariablesFromGenericInterfaces(</span>
<span class="nc" id="L279">            ((Class) genericInterface).getGenericInterfaces(), typeVariableMap);</span>
      }
    }
<span class="nc" id="L282">  }</span>

  /**
   * Read the {@link TypeVariable TypeVariables} from the supplied {@link ParameterizedType}
   * and add mappings corresponding to the {@link TypeVariable#getName TypeVariable name} -&gt;
   * concrete type to the supplied {@link Map}.
   * &lt;p&gt;Consider this case:
   * &lt;pre class=&quot;code&gt;
   * public interface Foo&lt;S, T&gt; {
   * ..
   * }
   * public class FooImpl implements Foo&lt;String, Integer&gt; {
   * ..
   * }&lt;/pre&gt;
   * For '&lt;code&gt;FooImpl&lt;/code&gt;' the following mappings would be added to the {@link Map}:
   * {S=java.lang.String, T=java.lang.Integer}.
   */
  private static void populateTypeMapFromParameterizedType(
      ParameterizedType type, Map typeVariableMap) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">    if (type.getRawType() instanceof Class) {</span>
<span class="nc" id="L302">      Type[] actualTypeArguments = type.getActualTypeArguments();</span>
<span class="nc" id="L303">      TypeVariable[] typeVariables = ((Class) type.getRawType()).getTypeParameters();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      for (int i = 0; i &lt; actualTypeArguments.length; i++) {</span>
<span class="nc" id="L305">        Type actualTypeArgument = actualTypeArguments[i];</span>
<span class="nc" id="L306">        TypeVariable variable = typeVariables[i];</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (actualTypeArgument instanceof Class) {</span>
<span class="nc" id="L308">          typeVariableMap.put(variable, actualTypeArgument);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        } else if (actualTypeArgument instanceof GenericArrayType) {</span>
<span class="nc" id="L310">          typeVariableMap.put(variable, actualTypeArgument);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        } else if (actualTypeArgument instanceof ParameterizedType) {</span>
<span class="nc" id="L312">          typeVariableMap.put(variable, ((ParameterizedType) actualTypeArgument).getRawType());</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        } else if (actualTypeArgument instanceof TypeVariable) {</span>
          // We have a type that is parameterized at instantiation time
          // the nearest match on the bridge method will be the bounded type.
<span class="nc" id="L316">          TypeVariable typeVariableArgument = (TypeVariable) actualTypeArgument;</span>
<span class="nc" id="L317">          Type resolvedType = (Type) typeVariableMap.get(typeVariableArgument);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">          if (resolvedType == null) {</span>
<span class="nc" id="L319">            resolvedType = extractClassForTypeVariable(typeVariableArgument);</span>
          }
<span class="nc bnc" id="L321" title="All 2 branches missed.">          if (resolvedType != null) {</span>
<span class="nc" id="L322">            typeVariableMap.put(variable, resolvedType);</span>
          }
        }
      }
    }
<span class="nc" id="L327">  }</span>

  /**
   * Extracts the bound '&lt;code&gt;Class&lt;/code&gt;' for a give {@link TypeVariable}.
   */
  private static Class extractClassForTypeVariable(TypeVariable typeVariable) {
<span class="nc" id="L333">    Type[] bounds = typeVariable.getBounds();</span>
<span class="nc" id="L334">    Type result = null;</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (bounds.length &gt; 0) {</span>
<span class="nc" id="L336">      Type bound = bounds[0];</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">      if (bound instanceof ParameterizedType) {</span>
<span class="nc" id="L338">        result = ((ParameterizedType) bound).getRawType();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">      } else if (bound instanceof Class) {</span>
<span class="nc" id="L340">        result = bound;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">      } else if (bound instanceof TypeVariable) {</span>
<span class="nc" id="L342">        result = extractClassForTypeVariable((TypeVariable) bound);</span>
      }
    }
<span class="nc bnc" id="L345" title="All 2 branches missed.">    return (result instanceof Class ? (Class) result : null);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>