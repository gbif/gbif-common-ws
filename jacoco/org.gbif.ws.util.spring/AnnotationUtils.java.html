<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotationUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common Web service</a> &gt; <a href="index.source.html" class="el_package">org.gbif.ws.util.spring</a> &gt; <span class="el_source">AnnotationUtils.java</span></div><h1>AnnotationUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2007 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gbif.ws.util.spring;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * &lt;p&gt;
 * General utility methods for working with annotations, handling bridge methods
 * (which the compiler generates for generic declarations) as well as super
 * methods (for optional &amp;quot;annotation inheritance&amp;quot;). Note that none of
 * this is provided by the JDK's introspection facilities themselves.
 * &lt;/p&gt;
 * &lt;p&gt;
 * As a general rule for runtime-retained annotations (e.g. for transaction
 * control, authorization or service exposure), always use the lookup methods on
 * this class (e.g., {@link #findAnnotation(Method, Class)},
 * {@link #getAnnotation(Method, Class)}, and {@link #getAnnotations(Method)})
 * instead of the plain annotation lookup methods in the JDK. You can still
 * explicitly choose between lookup on the given class level only ({@link #getAnnotation(Method, Class)})
 * and lookup in the entire inheritance hierarchy of the given method ({@link #findAnnotation(Method, Class)}).
 * &lt;/p&gt;
 *
 * @author Rod Johnson
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @author Mark Fisher
 * @see java.lang.reflect.Method#getAnnotations()
 * @see java.lang.reflect.Method#getAnnotation(Class)
 * @since 2.0
 */
<span class="nc" id="L51">public abstract class AnnotationUtils {</span>

  /**
   * The attribute name for annotations with a single element.
   */
  static final String VALUE = &quot;value&quot;;


  /**
   * &lt;p&gt;
   * Get all {@link Annotation Annotations} from the supplied {@link Method}.
   * &lt;/p&gt;
   * &lt;p&gt;
   * Correctly handles bridge {@link Method Methods} generated by the
   * compiler.
   * &lt;/p&gt;
   *
   * @param method the method to look for annotations on
   *
   * @return the annotations found
   */
  public static Annotation[] getAnnotations(final Method method) {
<span class="nc" id="L73">    return BridgeMethodResolver.findBridgedMethod(method).getAnnotations();</span>
  }

  /**
   * &lt;p&gt;
   * Get a single {@link Annotation} of &lt;code&gt;annotationType&lt;/code&gt; from the
   * supplied {@link Method}.
   * &lt;/p&gt;
   * &lt;p&gt;
   * Correctly handles bridge {@link Method Methods} generated by the
   * compiler.
   * &lt;/p&gt;
   *
   * @param method         the method to look for annotations on
   * @param annotationType the annotation class to look for
   *
   * @return the annotations found
   */
  public static &lt;A extends Annotation&gt; A getAnnotation(final Method method, final Class&lt;A&gt; annotationType) {
<span class="nc" id="L92">    return BridgeMethodResolver.findBridgedMethod(method).getAnnotation(annotationType);</span>
  }

  /**
   * &lt;p&gt;
   * Get a single {@link Annotation} of &lt;code&gt;annotationType&lt;/code&gt; from the
   * supplied {@link Method}, traversing its super methods if no annotation
   * can be found on the given method itself.
   * &lt;/p&gt;
   * &lt;p&gt;
   * Annotations on methods are not inherited by default, so we need to handle
   * this explicitly.
   * &lt;/p&gt;
   *
   * @param method         the method to look for annotations on
   * @param annotationType the annotation class to look for
   *
   * @return the annotation of the given type found, or &lt;code&gt;null&lt;/code&gt;
   */
  public static &lt;A extends Annotation&gt; A findAnnotation(final Method method, final Class&lt;A&gt; annotationType) {
<span class="nc" id="L112">    A annotation = getAnnotation(method, annotationType);</span>
<span class="nc" id="L113">    Class&lt;?&gt; cl = method.getDeclaringClass();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    while (annotation == null) {</span>
<span class="nc" id="L115">      cl = cl.getSuperclass();</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">      if (cl == null || cl.equals(Object.class)) {</span>
<span class="nc" id="L117">        break;</span>
      }
      try {
<span class="nc" id="L120">        Method equivalentMethod = cl.getDeclaredMethod(method.getName(), method.getParameterTypes());</span>
<span class="nc" id="L121">        annotation = getAnnotation(equivalentMethod, annotationType);</span>
<span class="nc" id="L122">      } catch (NoSuchMethodException ex) {</span>
        // We're done...
<span class="nc" id="L124">      }</span>
    }
<span class="nc" id="L126">    return annotation;</span>
  }

  /**
   * &lt;p&gt;
   * Get a single {@link Annotation} of &lt;code&gt;annotationType&lt;/code&gt; from the
   * supplied {@link Class}, traversing its interfaces and super classes
   * if no annotation can be found on the given class itself.
   * &lt;/p&gt;
   * &lt;p&gt;
   * This method explicitly handles class-level annotations which are not
   * declared as {@link java.lang.annotation.Inherited inherited} as well as
   * annotations on interfaces.
   * &lt;/p&gt;
   *
   * @param clazz          the class to look for annotations on
   * @param annotationType the annotation class to look for
   *
   * @return the annotation of the given type found, or &lt;code&gt;null&lt;/code&gt;
   */
  public static &lt;A extends Annotation&gt; A findAnnotation(final Class&lt;?&gt; clazz, final Class&lt;A&gt; annotationType) {
<span class="nc" id="L147">    Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="nc" id="L148">    A annotation = clazz.getAnnotation(annotationType);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">    if (annotation != null) {</span>
<span class="nc" id="L150">      return annotation;</span>
    }
<span class="nc bnc" id="L152" title="All 2 branches missed.">    for (Class&lt;?&gt; ifc : clazz.getInterfaces()) {</span>
<span class="nc" id="L153">      annotation = findAnnotation(ifc, annotationType);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      if (annotation != null) {</span>
<span class="nc" id="L155">        return annotation;</span>
      }
    }
<span class="nc bnc" id="L158" title="All 4 branches missed.">    if (clazz.getSuperclass() == null || Object.class.equals(clazz.getSuperclass())) {</span>
<span class="nc" id="L159">      return null;</span>
    }
<span class="nc" id="L161">    return findAnnotation(clazz.getSuperclass(), annotationType);</span>
  }

  /**
   * &lt;p&gt;
   * Finds the first {@link Class} in the inheritance hierarchy of the
   * specified &lt;code&gt;clazz&lt;/code&gt; (including the specified
   * &lt;code&gt;clazz&lt;/code&gt; itself) which declares an annotation for the
   * specified &lt;code&gt;annotationType&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if not
   * found. If the supplied &lt;code&gt;clazz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
   * &lt;code&gt;null&lt;/code&gt; will be returned.
   * &lt;/p&gt;
   * &lt;p&gt;
   * If the supplied &lt;code&gt;clazz&lt;/code&gt; is an interface, only the interface
   * itself will be checked; the inheritance hierarchy for interfaces will not
   * be traversed.
   * &lt;/p&gt;
   * &lt;p&gt;
   * The standard {@link Class} API does not provide a mechanism for
   * determining which class in an inheritance hierarchy actually declares an
   * {@link Annotation}, so we need to handle this explicitly.
   * &lt;/p&gt;
   *
   * @param annotationType the Class object corresponding to the annotation type
   * @param clazz          the Class object corresponding to the class on which to
   *                       check for the annotation, or &lt;code&gt;null&lt;/code&gt;.
   *
   * @return the first {@link Class} in the inheritance hierarchy of the
   *         specified &lt;code&gt;clazz&lt;/code&gt; which declares an annotation for the specified
   *         &lt;code&gt;annotationType&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if not found.
   *
   * @see Class#isAnnotationPresent(Class)
   * @see Class#getDeclaredAnnotations()
   */
  public static Class&lt;?&gt; findAnnotationDeclaringClass(final Class&lt;? extends Annotation&gt; annotationType,
    final Class&lt;?&gt; clazz) {
<span class="nc" id="L197">    Assert.notNull(annotationType, &quot;annotationType must not be null&quot;);</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">    if ((clazz == null) || clazz.equals(Object.class)) {</span>
<span class="nc" id="L199">      return null;</span>
    }
    // else...
<span class="nc bnc" id="L202" title="All 2 branches missed.">    return (isAnnotationDeclaredLocally(annotationType, clazz)) ? clazz</span>
<span class="nc" id="L203">      : findAnnotationDeclaringClass(annotationType, clazz.getSuperclass());</span>
  }

  /**
   * &lt;p&gt;
   * Returns &lt;code&gt;true&lt;/code&gt; if an annotation for the specified
   * &lt;code&gt;annotationType&lt;/code&gt; is declared locally on the supplied
   * &lt;code&gt;clazz&lt;/code&gt;, else &lt;code&gt;false&lt;/code&gt;. The supplied
   * {@link Class} object may represent any type.
   * &lt;/p&gt;
   * &lt;p&gt;
   * Note: this method does &lt;strong&gt;not&lt;/strong&gt; determine if the annotation
   * is {@link java.lang.annotation.Inherited inherited}. For greater clarity
   * regarding inherited annotations, consider using
   * {@link #isAnnotationInherited(Class, Class)} instead.
   * &lt;/p&gt;
   *
   * @param annotationType the Class object corresponding to the annotation type
   * @param clazz          the Class object corresponding to the class on which to
   *                       check for the annotation
   *
   * @return &lt;code&gt;true&lt;/code&gt; if an annotation for the specified
   *         &lt;code&gt;annotationType&lt;/code&gt; is declared locally on the supplied &lt;code&gt;clazz&lt;/code&gt;
   *
   * @see Class#getDeclaredAnnotations()
   * @see #isAnnotationInherited(Class, Class)
   */
  public static boolean isAnnotationDeclaredLocally(final Class&lt;? extends Annotation&gt; annotationType,
    final Class&lt;?&gt; clazz) {
<span class="nc" id="L232">    Assert.notNull(annotationType, &quot;annotationType must not be null&quot;);</span>
<span class="nc" id="L233">    Assert.notNull(clazz, &quot;clazz must not be null&quot;);</span>
<span class="nc" id="L234">    boolean declaredLocally = false;</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">    for (final Annotation annotation : Arrays.asList(clazz.getDeclaredAnnotations())) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">      if (annotation.annotationType().equals(annotationType)) {</span>
<span class="nc" id="L237">        declaredLocally = true;</span>
<span class="nc" id="L238">        break;</span>
      }
<span class="nc" id="L240">    }</span>
<span class="nc" id="L241">    return declaredLocally;</span>
  }

  /**
   * &lt;p&gt;
   * Returns &lt;code&gt;true&lt;/code&gt; if an annotation for the specified
   * &lt;code&gt;annotationType&lt;/code&gt; is present on the supplied
   * &lt;code&gt;clazz&lt;/code&gt; and is
   * {@link java.lang.annotation.Inherited inherited} (i.e., not declared
   * locally for the class), else &lt;code&gt;false&lt;/code&gt;.
   * &lt;/p&gt;
   * &lt;p&gt;
   * If the supplied &lt;code&gt;clazz&lt;/code&gt; is an interface, only the interface
   * itself will be checked. In accord with standard meta-annotation
   * semantics, the inheritance hierarchy for interfaces will not be
   * traversed. See the {@link java.lang.annotation.Inherited JavaDoc} for the
   * &amp;#064;Inherited meta-annotation for further details regarding annotation
   * inheritance.
   * &lt;/p&gt;
   *
   * @param annotationType the Class object corresponding to the annotation type
   * @param clazz          the Class object corresponding to the class on which to
   *                       check for the annotation
   *
   * @return &lt;code&gt;true&lt;/code&gt; if an annotation for the specified
   *         &lt;code&gt;annotationType&lt;/code&gt; is present on the supplied &lt;code&gt;clazz&lt;/code&gt;
   *         and is {@link java.lang.annotation.Inherited inherited}
   *
   * @see Class#isAnnotationPresent(Class)
   * @see #isAnnotationDeclaredLocally(Class, Class)
   */
  public static boolean isAnnotationInherited(final Class&lt;? extends Annotation&gt; annotationType, final Class&lt;?&gt; clazz) {
<span class="nc" id="L273">    Assert.notNull(annotationType, &quot;annotationType must not be null&quot;);</span>
<span class="nc" id="L274">    Assert.notNull(clazz, &quot;clazz must not be null&quot;);</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">    return (clazz.isAnnotationPresent(annotationType) &amp;&amp; !isAnnotationDeclaredLocally(annotationType, clazz));</span>
  }

  /**
   * Retrieve the given annotation's attributes as a Map.
   *
   * @param annotation the annotation to retrieve the attributes for
   *
   * @return the Map of annotation attributes, with attribute names as keys
   *         and corresponding attribute values as values
   */
  public static Map&lt;String, Object&gt; getAnnotationAttributes(final Annotation annotation) {
<span class="nc" id="L287">    final Map&lt;String, Object&gt; attrs = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L288">    final Method[] methods = annotation.annotationType().getDeclaredMethods();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">    for (int j = 0; j &lt; methods.length; j++) {</span>
<span class="nc" id="L290">      final Method method = methods[j];</span>
<span class="nc bnc" id="L291" title="All 4 branches missed.">      if (method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() != void.class) {</span>
        try {
<span class="nc" id="L293">          attrs.put(method.getName(), method.invoke(annotation));</span>
<span class="nc" id="L294">        } catch (final Exception ex) {</span>
<span class="nc" id="L295">          throw new IllegalStateException(&quot;Could not obtain annotation attribute values&quot;, ex);</span>
<span class="nc" id="L296">        }</span>
      }
    }
<span class="nc" id="L299">    return attrs;</span>
  }

  /**
   * Retrieve the &lt;em&gt;value&lt;/em&gt; of the &lt;code&gt;&amp;quot;value&amp;quot;&lt;/code&gt;
   * attribute of a single-element Annotation, given an annotation instance.
   *
   * @param annotation the annotation instance from which to retrieve the value
   *
   * @return the attribute value, or &lt;code&gt;null&lt;/code&gt; if not found
   *
   * @see #getValue(Annotation, String)
   */
  public static Object getValue(final Annotation annotation) {
<span class="nc" id="L313">    return getValue(annotation, VALUE);</span>
  }

  /**
   * Retrieve the &lt;em&gt;value&lt;/em&gt; of a named Annotation attribute, given an
   * annotation instance.
   *
   * @param annotation    the annotation instance from which to retrieve the value
   * @param attributeName the name of the attribute value to retrieve
   *
   * @return the attribute value, or &lt;code&gt;null&lt;/code&gt; if not found
   *
   * @see #getValue(Annotation)
   */
  public static Object getValue(final Annotation annotation, final String attributeName) {
    try {
<span class="nc" id="L329">      final Method method = annotation.annotationType().getDeclaredMethod(attributeName, new Class[0]);</span>
<span class="nc" id="L330">      return method.invoke(annotation);</span>
<span class="nc" id="L331">    } catch (final Exception ex) {</span>
<span class="nc" id="L332">      return null;</span>
    }
  }

  /**
   * Retrieve the &lt;em&gt;default value&lt;/em&gt; of the
   * &lt;code&gt;&amp;quot;value&amp;quot;&lt;/code&gt; attribute of a single-element
   * Annotation, given an annotation instance.
   *
   * @param annotation the annotation instance from which to retrieve
   *                   the default value
   *
   * @return the default value, or &lt;code&gt;null&lt;/code&gt; if not found
   *
   * @see #getDefaultValue(Annotation, String)
   */
  public static Object getDefaultValue(final Annotation annotation) {
<span class="nc" id="L349">    return getDefaultValue(annotation, VALUE);</span>
  }

  /**
   * Retrieve the &lt;em&gt;default value&lt;/em&gt; of a named Annotation attribute,
   * given an annotation instance.
   *
   * @param annotation    the annotation instance from which to retrieve
   *                      the default value
   * @param attributeName the name of the attribute value to retrieve
   *
   * @return the default value of the named attribute, or &lt;code&gt;null&lt;/code&gt;
   *         if not found.
   *
   * @see #getDefaultValue(Class, String)
   */
  public static Object getDefaultValue(final Annotation annotation, final String attributeName) {
<span class="nc" id="L366">    return getDefaultValue(annotation.annotationType(), attributeName);</span>
  }

  /**
   * Retrieve the &lt;em&gt;default value&lt;/em&gt; of the
   * &lt;code&gt;&amp;quot;value&amp;quot;&lt;/code&gt; attribute of a single-element
   * Annotation, given the {@link Class annotation type}.
   *
   * @param annotationType the &lt;em&gt;annotation type&lt;/em&gt; for which the
   *                       default value should be retrieved
   *
   * @return the default value, or &lt;code&gt;null&lt;/code&gt; if not found
   *
   * @see #getDefaultValue(Class, String)
   */
  public static Object getDefaultValue(final Class&lt;? extends Annotation&gt; annotationType) {
<span class="nc" id="L382">    return getDefaultValue(annotationType, VALUE);</span>
  }

  /**
   * Retrieve the &lt;em&gt;default value&lt;/em&gt; of a named Annotation attribute,
   * given the {@link Class annotation type}.
   *
   * @param annotationType the &lt;em&gt;annotation type&lt;/em&gt; for which the
   *                       default value should be retrieved
   * @param attributeName  the name of the attribute value to retrieve.
   *
   * @return the default value of the named attribute, or &lt;code&gt;null&lt;/code&gt;
   *         if not found
   *
   * @see #getDefaultValue(Annotation, String)
   */
  public static Object getDefaultValue(final Class&lt;? extends Annotation&gt; annotationType, final String attributeName) {
    try {
<span class="nc" id="L400">      final Method method = annotationType.getDeclaredMethod(attributeName, new Class[0]);</span>
<span class="nc" id="L401">      return method.getDefaultValue();</span>
<span class="nc" id="L402">    } catch (final Exception ex) {</span>
<span class="nc" id="L403">      return null;</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>