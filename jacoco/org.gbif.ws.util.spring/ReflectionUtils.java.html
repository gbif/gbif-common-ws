<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReflectionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common Web service</a> &gt; <a href="index.source.html" class="el_package">org.gbif.ws.util.spring</a> &gt; <span class="el_source">ReflectionUtils.java</span></div><h1>ReflectionUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.ws.util.spring;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * Simple utility class for working with the reflection API and handling
 * reflection exceptions.
 * &lt;p&gt;Only intended for internal use.
 *
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Rod Johnson
 * @author Costin Leau
 * @author Sam Brannen
 * @since 1.2.2
 */
<span class="nc" id="L37">public abstract class ReflectionUtils {</span>

  /**
   * Attempt to find a {@link Field field} on the supplied {@link Class} with
   * the supplied &lt;code&gt;name&lt;/code&gt; and {@link Class type}. Searches all
   * superclasses up to {@link Object}.
   *
   * @param clazz the class to introspect
   * @param name  the name of the field
   * @param type  the type of the field
   *
   * @return the corresponding Field object, or &lt;code&gt;null&lt;/code&gt; if not found
   *
   * @throws IllegalArgumentException if the class or field type is
   *                                  &lt;code&gt;null&lt;/code&gt; or if the field name is &lt;em&gt;empty&lt;/em&gt;
   */
  public static Field findField(final Class clazz, final String name, final Class type) {
<span class="nc" id="L54">    Assert.notNull(clazz, &quot;The 'class to introspect' supplied to findField() can not be null.&quot;);</span>
<span class="nc" id="L55">    Assert.hasText(name, &quot;The field name supplied to findField() can not be empty.&quot;);</span>
<span class="nc" id="L56">    Assert.notNull(type, &quot;The field type supplied to findField() can not be null.&quot;);</span>
<span class="nc" id="L57">    Class searchType = clazz;</span>
<span class="nc bnc" id="L58" title="All 4 branches missed.">    while (!Object.class.equals(searchType) &amp;&amp; searchType != null) {</span>
<span class="nc" id="L59">      final Field[] fields = searchType.getDeclaredFields();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L61">        Field field = fields[i];</span>
<span class="nc bnc" id="L62" title="All 4 branches missed.">        if (name.equals(field.getName()) &amp;&amp; type.equals(field.getType())) {</span>
<span class="nc" id="L63">          return field;</span>
        }
      }
<span class="nc" id="L66">      searchType = searchType.getSuperclass();</span>
<span class="nc" id="L67">    }</span>
<span class="nc" id="L68">    return null;</span>
  }

  /**
   * Set the field represented by the supplied {@link Field field object} on
   * the specified {@link Object target object} to the specified
   * &lt;code&gt;value&lt;/code&gt;. In accordance with
   * {@link Field#set(Object, Object)} semantics, the new value is
   * automatically unwrapped if the underlying field has a primitive type.
   * &lt;p&gt;Thrown exceptions are handled via a call to
   * {@link #handleReflectionException(Exception)}.
   *
   * @param field  the field to set
   * @param target the target object on which to set the field
   * @param value  the value to set; may be &lt;code&gt;null&lt;/code&gt;
   */
  public static void setField(Field field, Object target, Object value) {
    try {
<span class="nc" id="L86">      field.set(target, value);</span>
<span class="nc" id="L87">    } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L88">      handleReflectionException(ex);</span>
<span class="nc" id="L89">      throw new IllegalStateException(</span>
<span class="nc" id="L90">          &quot;Unexpected reflection exception - &quot; + ex.getClass().getName() + &quot;: &quot; + ex.getMessage());</span>
<span class="nc" id="L91">    }</span>
<span class="nc" id="L92">  }</span>

  /**
   * Attempt to find a {@link Method} on the supplied class with the supplied name
   * and no parameters. Searches all superclasses up to &lt;code&gt;Object&lt;/code&gt;.
   * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if no {@link Method} can be found.
   *
   * @param clazz the class to introspect
   * @param name  the name of the method
   *
   * @return the Method object, or &lt;code&gt;null&lt;/code&gt; if none found
   */
  public static Method findMethod(Class clazz, String name) {
<span class="nc" id="L105">    return findMethod(clazz, name, new Class[0]);</span>
  }

  /**
   * Attempt to find a {@link Method} on the supplied class with the supplied name
   * and parameter types. Searches all superclasses up to &lt;code&gt;Object&lt;/code&gt;.
   * &lt;p&gt;Returns &lt;code&gt;null&lt;/code&gt; if no {@link Method} can be found.
   *
   * @param clazz      the class to introspect
   * @param name       the name of the method
   * @param paramTypes the parameter types of the method
   *
   * @return the Method object, or &lt;code&gt;null&lt;/code&gt; if none found
   */
  public static Method findMethod(Class clazz, String name, Class[] paramTypes) {
<span class="nc" id="L120">    Assert.notNull(clazz, &quot;Class must not be null&quot;);</span>
<span class="nc" id="L121">    Assert.notNull(name, &quot;Method name must not be null&quot;);</span>
<span class="nc" id="L122">    Class searchType = clazz;</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">    while (!Object.class.equals(searchType) &amp;&amp; searchType != null) {</span>
      Method[] methods =
<span class="nc bnc" id="L125" title="All 2 branches missed.">          (searchType.isInterface() ? searchType.getMethods() : searchType.getDeclaredMethods());</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">      for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L127">        Method method = methods[i];</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (name.equals(method.getName())</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            &amp;&amp; Arrays.equals(paramTypes, method.getParameterTypes())) {</span>
<span class="nc" id="L130">          return method;</span>
        }
      }
<span class="nc" id="L133">      searchType = searchType.getSuperclass();</span>
<span class="nc" id="L134">    }</span>
<span class="nc" id="L135">    return null;</span>
  }

  /**
   * Invoke the specified {@link Method} against the supplied target object
   * with no arguments. The target object can be &lt;code&gt;null&lt;/code&gt; when
   * invoking a static {@link Method}.
   * &lt;p&gt;Thrown exceptions are handled via a call to {@link #handleReflectionException}.
   *
   * @param method the method to invoke
   * @param target the target object to invoke the method on
   *
   * @return the invocation result, if any
   *
   * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
   */
  public static Object invokeMethod(Method method, Object target) {
<span class="nc" id="L152">    return invokeMethod(method, target, null);</span>
  }

  /**
   * Invoke the specified {@link Method} against the supplied target object
   * with the supplied arguments. The target object can be &lt;code&gt;null&lt;/code&gt;
   * when invoking a static {@link Method}.
   * &lt;p&gt;Thrown exceptions are handled via a call to {@link #handleReflectionException}.
   *
   * @param method the method to invoke
   * @param target the target object to invoke the method on
   * @param args   the invocation arguments (may be &lt;code&gt;null&lt;/code&gt;)
   *
   * @return the invocation result, if any
   *
   * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
   */
  public static Object invokeMethod(Method method, Object target, Object[] args) {
    try {
<span class="nc" id="L171">      return method.invoke(target, args);</span>
<span class="nc" id="L172">    } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L173">      handleReflectionException(ex);</span>
<span class="nc" id="L174">      throw new IllegalStateException(</span>
<span class="nc" id="L175">          &quot;Unexpected reflection exception - &quot; + ex.getClass().getName() + &quot;: &quot; + ex.getMessage());</span>
<span class="nc" id="L176">    } catch (InvocationTargetException ex) {</span>
<span class="nc" id="L177">      handleReflectionException(ex);</span>
<span class="nc" id="L178">      throw new IllegalStateException(</span>
<span class="nc" id="L179">          &quot;Unexpected reflection exception - &quot; + ex.getClass().getName() + &quot;: &quot; + ex.getMessage());</span>
    }
  }

  /**
   * Handle the given reflection exception. Should only be called if
   * no checked exception is expected to be thrown by the target method.
   * &lt;p&gt;Throws the underlying RuntimeException or Error in case of an
   * InvocationTargetException with such a root cause. Throws an
   * IllegalStateException with an appropriate message else.
   *
   * @param ex the reflection exception to handle
   */
  public static void handleReflectionException(Exception ex) {
<span class="nc bnc" id="L193" title="All 2 branches missed.">    if (ex instanceof NoSuchMethodException) {</span>
<span class="nc" id="L194">      throw new IllegalStateException(&quot;Method not found: &quot; + ex.getMessage());</span>
    }
<span class="nc bnc" id="L196" title="All 2 branches missed.">    if (ex instanceof IllegalAccessException) {</span>
<span class="nc" id="L197">      throw new IllegalStateException(&quot;Could not access method: &quot; + ex.getMessage());</span>
    }
<span class="nc bnc" id="L199" title="All 2 branches missed.">    if (ex instanceof InvocationTargetException) {</span>
<span class="nc" id="L200">      handleInvocationTargetException((InvocationTargetException) ex);</span>
    }
<span class="nc" id="L202">    throw new IllegalStateException(</span>
<span class="nc" id="L203">        &quot;Unexpected reflection exception - &quot; + ex.getClass().getName() + &quot;: &quot; + ex.getMessage());</span>
  }

  /**
   * Handle the given invocation target exception. Should only be called if
   * no checked exception is expected to be thrown by the target method.
   * &lt;p&gt;Throws the underlying RuntimeException or Error in case of such
   * a root cause. Throws an IllegalStateException else.
   *
   * @param ex the invocation target exception to handle
   */
  public static void handleInvocationTargetException(InvocationTargetException ex) {
<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (ex.getTargetException() instanceof RuntimeException) {</span>
<span class="nc" id="L216">      throw (RuntimeException) ex.getTargetException();</span>
    }
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (ex.getTargetException() instanceof Error) {</span>
<span class="nc" id="L219">      throw (Error) ex.getTargetException();</span>
    }
<span class="nc" id="L221">    throw new IllegalStateException(</span>
        &quot;Unexpected exception thrown by method - &quot;
<span class="nc" id="L223">            + ex.getTargetException().getClass().getName()</span>
            + &quot;: &quot;
<span class="nc" id="L225">            + ex.getTargetException().getMessage());</span>
  }

  /**
   * Rethrow the given {@link Throwable exception}, which is presumably the
   * &lt;em&gt;target exception&lt;/em&gt; of an {@link InvocationTargetException}.
   * Should only be called if no checked exception is expected to be thrown by
   * the target method.
   * &lt;p&gt; Rethrows the underlying exception cast to an {@link Exception} or
   * {@link Error} if appropriate; otherwise, throws an
   * {@link IllegalStateException}.
   *
   * @param ex the exception to rethrow
   *
   * @throws Exception the rethrown exception (in case of a checked exception)
   */
  public static void rethrowException(Throwable ex) throws Exception {
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (ex instanceof Exception) {</span>
<span class="nc" id="L243">      throw (Exception) ex;</span>
    }
<span class="nc bnc" id="L245" title="All 2 branches missed.">    if (ex instanceof Error) {</span>
<span class="nc" id="L246">      throw (Error) ex;</span>
    }
<span class="nc" id="L248">    throw new IllegalStateException(</span>
        &quot;Unexpected exception thrown by method - &quot;
<span class="nc" id="L250">            + ex.getClass().getName()</span>
            + &quot;: &quot;
<span class="nc" id="L252">            + ex.getMessage());</span>
  }

  /**
   * Determine whether the given method explicitly declares the given exception
   * or one of its superclasses, which means that an exception of that type
   * can be propagated as-is within a reflective invocation.
   *
   * @param method        the declaring method
   * @param exceptionType the exception to throw
   *
   * @return &lt;code&gt;true&lt;/code&gt; if the exception can be thrown as-is;
   *         &lt;code&gt;false&lt;/code&gt; if it needs to be wrapped
   */
  public static boolean declaresException(Method method, Class exceptionType) {
<span class="nc" id="L267">    Assert.notNull(method, &quot;Method must not be null&quot;);</span>
<span class="nc" id="L268">    Class[] declaredExceptions = method.getExceptionTypes();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">    for (int i = 0; i &lt; declaredExceptions.length; i++) {</span>
<span class="nc" id="L270">      Class declaredException = declaredExceptions[i];</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (declaredException.isAssignableFrom(exceptionType)) {</span>
<span class="nc" id="L272">        return true;</span>
      }
    }
<span class="nc" id="L275">    return false;</span>
  }

  /**
   * Determine whether the given field is a &quot;public static final&quot; constant.
   *
   * @param field the field to check
   */
  public static boolean isPublicStaticFinal(Field field) {
<span class="nc" id="L284">    int modifiers = field.getModifiers();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">    return (Modifier.isPublic(modifiers)</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        &amp;&amp; Modifier.isStatic(modifiers)</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        &amp;&amp; Modifier.isFinal(modifiers));</span>
  }

  /**
   * Make the given field accessible, explicitly setting it accessible if necessary.
   * The &lt;code&gt;setAccessible(true)&lt;/code&gt; method is only called when actually necessary,
   * to avoid unnecessary conflicts with a JVM SecurityManager (if active).
   *
   * @param field the field to make accessible
   *
   * @see java.lang.reflect.Field#setAccessible
   */
  public static void makeAccessible(Field field) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">    if (!Modifier.isPublic(field.getModifiers())</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        || !Modifier.isPublic(field.getDeclaringClass().getModifiers())) {</span>
<span class="nc" id="L302">      field.setAccessible(true);</span>
    }
<span class="nc" id="L304">  }</span>

  /**
   * Make the given method accessible, explicitly setting it accessible if necessary.
   * The &lt;code&gt;setAccessible(true)&lt;/code&gt; method is only called when actually necessary,
   * to avoid unnecessary conflicts with a JVM SecurityManager (if active).
   *
   * @param method the method to make accessible
   *
   * @see java.lang.reflect.Method#setAccessible
   */
  public static void makeAccessible(Method method) {
<span class="nc bnc" id="L316" title="All 2 branches missed.">    if (!Modifier.isPublic(method.getModifiers())</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {</span>
<span class="nc" id="L318">      method.setAccessible(true);</span>
    }
<span class="nc" id="L320">  }</span>

  /**
   * Make the given constructor accessible, explicitly setting it accessible if necessary.
   * The &lt;code&gt;setAccessible(true)&lt;/code&gt; method is only called when actually necessary,
   * to avoid unnecessary conflicts with a JVM SecurityManager (if active).
   *
   * @param ctor the constructor to make accessible
   *
   * @see java.lang.reflect.Constructor#setAccessible
   */
  public static void makeAccessible(Constructor ctor) {
<span class="nc bnc" id="L332" title="All 2 branches missed.">    if (!Modifier.isPublic(ctor.getModifiers())</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) {</span>
<span class="nc" id="L334">      ctor.setAccessible(true);</span>
    }
<span class="nc" id="L336">  }</span>

  /**
   * Perform the given callback operation on all matching methods of the
   * given class and superclasses.
   * &lt;p&gt;The same named method occurring on subclass and superclass will
   * appear twice, unless excluded by a {@link MethodFilter}.
   *
   * @param targetClass class to start looking at
   * @param mc          the callback to invoke for each method
   *
   * @see #doWithMethods(Class, MethodCallback, MethodFilter)
   */
  public static void doWithMethods(Class targetClass, MethodCallback mc)
      throws IllegalArgumentException {
<span class="nc" id="L351">    doWithMethods(targetClass, mc, null);</span>
<span class="nc" id="L352">  }</span>

  /**
   * Perform the given callback operation on all matching methods of the
   * given class and superclasses.
   * &lt;p&gt;The same named method occurring on subclass and superclass will
   * appear twice, unless excluded by the specified {@link MethodFilter}.
   *
   * @param targetClass class to start looking at
   * @param mc          the callback to invoke for each method
   * @param mf          the filter that determines the methods to apply the callback to
   */
  public static void doWithMethods(Class targetClass, MethodCallback mc, MethodFilter mf)
      throws IllegalArgumentException {

    // Keep backing up the inheritance hierarchy.
    do {
<span class="nc" id="L369">      Method[] methods = targetClass.getDeclaredMethods();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">      for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">        if (mf != null &amp;&amp; !mf.matches(methods[i])) {</span>
<span class="nc" id="L372">          continue;</span>
        }
        try {
<span class="nc" id="L375">          mc.doWith(methods[i]);</span>
<span class="nc" id="L376">        } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L377">          throw new IllegalStateException(</span>
<span class="nc" id="L378">              &quot;Shouldn't be illegal to access method '&quot; + methods[i].getName() + &quot;': &quot; + ex);</span>
<span class="nc" id="L379">        }</span>
      }
<span class="nc" id="L381">      targetClass = targetClass.getSuperclass();</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">    } while (targetClass != null);</span>
<span class="nc" id="L383">  }</span>

  /**
   * Get all declared methods on the leaf class and all superclasses.
   * Leaf class methods are included first.
   */
  public static Method[] getAllDeclaredMethods(Class leafClass) throws IllegalArgumentException {
<span class="nc" id="L390">    final List list = new LinkedList();</span>
<span class="nc" id="L391">    doWithMethods(</span>
        leafClass,
<span class="nc" id="L393">        new MethodCallback() {</span>
          @Override
          public void doWith(Method m) {
<span class="nc" id="L396">            list.add(m);</span>
<span class="nc" id="L397">          }</span>
        });
<span class="nc" id="L399">    return (Method[]) list.toArray(new Method[list.size()]);</span>
  }

  /**
   * Invoke the given callback on all fields in the target class,
   * going up the class hierarchy to get all declared fields.
   *
   * @param targetClass the target class to analyze
   * @param fc          the callback to invoke for each field
   */
  public static void doWithFields(Class targetClass, FieldCallback fc)
      throws IllegalArgumentException {
<span class="nc" id="L411">    doWithFields(targetClass, fc, null);</span>
<span class="nc" id="L412">  }</span>

  /**
   * Invoke the given callback on all fields in the target class,
   * going up the class hierarchy to get all declared fields.
   *
   * @param targetClass the target class to analyze
   * @param fc          the callback to invoke for each field
   * @param ff          the filter that determines the fields to apply the callback to
   */
  public static void doWithFields(Class targetClass, FieldCallback fc, FieldFilter ff)
      throws IllegalArgumentException {

    // Keep backing up the inheritance hierarchy.
    do {
      // Copy each field declared on this class unless it's static or file.
<span class="nc" id="L428">      Field[] fields = targetClass.getDeclaredFields();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">      for (int i = 0; i &lt; fields.length; i++) {</span>
        // Skip static and final fields.
<span class="nc bnc" id="L431" title="All 4 branches missed.">        if (ff != null &amp;&amp; !ff.matches(fields[i])) {</span>
<span class="nc" id="L432">          continue;</span>
        }
        try {
<span class="nc" id="L435">          fc.doWith(fields[i]);</span>
<span class="nc" id="L436">        } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L437">          throw new IllegalStateException(</span>
<span class="nc" id="L438">              &quot;Shouldn't be illegal to access field '&quot; + fields[i].getName() + &quot;': &quot; + ex);</span>
<span class="nc" id="L439">        }</span>
      }
<span class="nc" id="L441">      targetClass = targetClass.getSuperclass();</span>
<span class="nc bnc" id="L442" title="All 4 branches missed.">    } while (targetClass != null &amp;&amp; targetClass != Object.class);</span>
<span class="nc" id="L443">  }</span>

  /**
   * Given the source object and the destination, which must be the same class
   * or a subclass, copy all fields, including inherited fields. Designed to
   * work on objects with public no-arg constructors.
   *
   * @throws IllegalArgumentException if the arguments are incompatible
   */
  public static void shallowCopyFieldState(final Object src, final Object dest)
      throws IllegalArgumentException {
<span class="nc bnc" id="L454" title="All 2 branches missed.">    if (src == null) {</span>
<span class="nc" id="L455">      throw new IllegalArgumentException(&quot;Source for field copy cannot be null&quot;);</span>
    }
<span class="nc bnc" id="L457" title="All 2 branches missed.">    if (dest == null) {</span>
<span class="nc" id="L458">      throw new IllegalArgumentException(&quot;Destination for field copy cannot be null&quot;);</span>
    }
<span class="nc bnc" id="L460" title="All 2 branches missed.">    if (!src.getClass().isAssignableFrom(dest.getClass())) {</span>
<span class="nc" id="L461">      throw new IllegalArgumentException(</span>
          &quot;Destination class [&quot;
<span class="nc" id="L463">              + dest.getClass().getName()</span>
              + &quot;] must be same or subclass as source class [&quot;
<span class="nc" id="L465">              + src.getClass().getName()</span>
              + &quot;]&quot;);
    }
<span class="nc" id="L468">    doWithFields(</span>
<span class="nc" id="L469">        src.getClass(),</span>
<span class="nc" id="L470">        new ReflectionUtils.FieldCallback() {</span>
          @Override
          public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
<span class="nc" id="L473">            makeAccessible(field);</span>
<span class="nc" id="L474">            Object srcValue = field.get(src);</span>
<span class="nc" id="L475">            field.set(dest, srcValue);</span>
<span class="nc" id="L476">          }</span>
        },
        ReflectionUtils.COPYABLE_FIELDS);
<span class="nc" id="L479">  }</span>

  /**
   * Action to take on each method.
   */
  public static interface MethodCallback {

    /**
     * Perform an operation using the given method.
     *
     * @param method the method to operate on
     */
    void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;
  }

  /**
   * Callback optionally used to method fields to be operated on by a method callback.
   */
  public static interface MethodFilter {

    /**
     * Determine whether the given method matches.
     *
     * @param method the method to check
     */
    boolean matches(Method method);
  }

  /**
   * Callback interface invoked on each field in the hierarchy.
   */
  public static interface FieldCallback {

    /**
     * Perform an operation using the given field.
     *
     * @param field the field to operate on
     */
    void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;
  }

  /**
   * Callback optionally used to filter fields to be operated on by a field callback.
   */
  public static interface FieldFilter {

    /**
     * Determine whether the given field matches.
     *
     * @param field the field to check
     */
    boolean matches(Field field);
  }

  /**
   * Pre-built FieldFilter that matches all non-static, non-final fields.
   */
<span class="nc" id="L536">  public static FieldFilter COPYABLE_FIELDS =</span>
<span class="nc" id="L537">      new FieldFilter() {</span>
        @Override
        public boolean matches(Field field) {
<span class="nc bnc" id="L540" title="All 2 branches missed.">          return !(Modifier.isStatic(field.getModifiers())</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">              || Modifier.isFinal(field.getModifiers()));</span>
        }
      };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>